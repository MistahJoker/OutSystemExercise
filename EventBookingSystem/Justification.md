Event Booking System by Flávio Gonçalves

First off I started by creating the classes and the relationships between them, to start the User class is only related to the Bookings by a "has a" connection meanning a Booking has a User but at the same time a User can have multiple Bookings. Then the Venue class that is linked to the Event class by a "contains" connection meanning multiple Events contains a Venue but a Venue can be used in multiple Events which also implies that on the deletion of a Venue all the Events linked to it should also be deleted, also linked to the Event class is the ISeatingType interface with a "uses" connection meanning an Event uses a ISeatingType. Lastly the Booking class is also connected to the Event class with the same type of connection as with the User class, this means that a Booking only has one Event but an Event can have multiple Bookings.
My reasonning to building the classes with this structure was we have one user he can buy multiple tickets (a Booking) to a concert (an Event), but a the same time the place (a Venue) that the concert is being held can also be the same place where a different user buys another ticket for a football match, this also addresses the different types of seating we need and why they are attached to the event as for the concert we might have open air seating but then for the football match we have sectionned seating. 

After definind the relatioships I started working with the classes/enties, I limited them to only what was strictly needed to complete the task at hand, I also tried to limit the properties within those classes to only those I would need for the project and a few that would make sense in a real life scenerio that would make the code much easier to both read and writte, I also created an override the ToString() function to make it easier to print out all the information needed.
- User.cs - for this class I only needed the Id as I didn't need to work with other information about the user like the name or age. I also added the List of Bookings but they are not attached direclty to the User, this meaning that when we load a user we have the option to load only the information relevant to them, in this case is only the id but it could also include the name and age, and we also have the possibility to load the user with the list of their bookings. This makes the class more flexible from a performance point of view as we don't need to load all the information related to the booking that could take a lot of place in memory as we might not want to always load the lisf of all the Bookings of that Userbut it's good to have the possibility to have and load the Bookings so that we don't need to load all the Bookings sepperatly and then filter out by the User.
- Venue.cs - the same logic from the User class applies here, only the information needed the Id and the Capacity and the list of Events, this is also the same logic between the User and Bookings. 
- Event.cs - for this class we have the other end of the relationship with the Venue, meanning on top of the necessary properties we also have the VenueId related to the Venue that the Event is being held at, I also added the full Venue object as it also makes it easier to have and call direcly on the code without having to load the venue each time we want to use it. On top of this I also added the list of Bookings like in the User class this is not required but can make it easier to work with.
- Booking.cs - this class has similar behaviours as to the previous class where we only need the UserId but I added the User property to make it easier. One property to point out is the PaymentStatus that is an Enum making it more fool-proof instead of using plain strings.
Some of the classe also have nullable properties and privat constructors because I used the Entity Framework to build the SQL Schema and both of these are needed to properly load these classes from the DataBase.

On the topic of the DataBase, as I mentioned before I used the EF tool from .NET as it makes it effortless to create the schema as soon as the DBContext is created. The context in this case is quite simple I added the classes I needed and added the relations. For the bookings I added an extra step to tell it how to store the PaymentStatus property and for the SeatingType for the Event it's a bit more complex since the mock date in this case is all created by hand and I assign the different types of seating there I didn't need to store the SeatingType but in a real world scenario, we could store some sort of text referencing wich type of seating is used in that event and when we load that Event we would have switch and then create the proper SeatingType for the Event.

For the Data I have different Repositories as Interfaces for each of the 4 main classes, this abstraction makes it simpler to use the Repositories as we don't need to know how we Get/Store or data we just knot that they do, this also makes it straightforward if we need to switch data sources. Each Reposiroty Interface is then used to create a MockUp class that has the implementation of the methods from the corresponding Interface. In this MockUp classes I decided to use on main MockUpDB class to act as an actual DB with all the information inside. When initialized the MockUpDB class creates objects for the different classes making it simpler as I only need to create date in one class and all the data is shared with the other MockUp classes making the data consistant across all of them.
